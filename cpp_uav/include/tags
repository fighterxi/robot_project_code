!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Direction	torres_etal_2016.hpp	/^struct Direction$/;"	s
INCLUDED_cgutil_hpp_	cgutil.hpp	13;"	d
INCLUDED_torres_etal_2016_hpp_	torres_etal_2016.hpp	13;"	d
baseEdge	torres_etal_2016.hpp	/^  LineSegment baseEdge;$/;"	m	struct:Direction
calculateDistance	cgutil.hpp	/^double calculateDistance(const LineSegment& edge, const geometry_msgs::Point& vertex)$/;"	f
calculateDistance	cgutil.hpp	/^inline double calculateDistance(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2)$/;"	f
calculateHorizontalAngle	cgutil.hpp	/^double calculateHorizontalAngle(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2)$/;"	f
calculatePathLength	torres_etal_2016.hpp	/^double calculatePathLength(const PointVector& path)$/;"	f
calculateSignedArea	cgutil.hpp	/^inline double calculateSignedArea(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2,$/;"	f
calculateVertexAngle	cgutil.hpp	/^double calculateVertexAngle(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2,$/;"	f
computeCCWPath	torres_etal_2016.hpp	/^PointVector computeCCWPath(PointVector path)$/;"	f
computeConvexCoverage	torres_etal_2016.hpp	/^bool computeConvexCoverage(const PointVector& polygon, double footprintWidth, double horizontalOverwrap,$/;"	f
computeConvexHull	cgutil.hpp	/^PointVector computeConvexHull(PointVector points)$/;"	f
computeMultiplePolygonCoverage	torres_etal_2016.hpp	/^PointVector computeMultiplePolygonCoverage(std::vector<PointVector> subPolygons, double footprintWidth,$/;"	f
computeOppositePath	torres_etal_2016.hpp	/^PointVector computeOppositePath(const PointVector& path)$/;"	f
decomposePolygon	cgutil.hpp	/^std::vector<PointVector> decomposePolygon(const PointVector& polygon)$/;"	f
findSecondOptimalPath	torres_etal_2016.hpp	/^bool findSecondOptimalPath(const PointVector& polygon, double footprintWidth, double horizontalOverwrap,$/;"	f
generateEdgeVector	cgutil.hpp	/^LineSegmentVector generateEdgeVector(const PointVector& vec, bool isClosed)$/;"	f
hasIntersection	cgutil.hpp	/^bool hasIntersection(const LineSegment& edge1, const LineSegment& edge2)$/;"	f
hasIntersection	cgutil.hpp	/^bool hasIntersection(const LineSegmentVector& vec1, const LineSegmentVector& vec2)$/;"	f
identifyOptimalAlternative	torres_etal_2016.hpp	/^PointVector identifyOptimalAlternative(const PointVector& polygon, const PointVector& path,$/;"	f
identifyOptimalSweepDir	torres_etal_2016.hpp	/^Direction identifyOptimalSweepDir(const PointVector& polygon)$/;"	f
isAdjacent	torres_etal_2016.hpp	/^bool isAdjacent(const PointVector& polygon1, const PointVector& polygon2)$/;"	f
isClockWise	torres_etal_2016.hpp	/^inline bool isClockWise(const PointVector& path)$/;"	f
isConvex	cgutil.hpp	/^inline bool isConvex(PointVector points)$/;"	f
localizeIntersection	cgutil.hpp	/^geometry_msgs::Point localizeIntersection(const LineSegment& edge1, const LineSegment& edge2)$/;"	f
operator !=	cgutil.hpp	/^bool operator!=(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2)$/;"	f
operator ==	cgutil.hpp	/^bool operator==(const geometry_msgs::Point& p1, const geometry_msgs::Point& p2)$/;"	f
opposedVertex	torres_etal_2016.hpp	/^  geometry_msgs::Point opposedVertex;$/;"	m	struct:Direction
reshapePath	torres_etal_2016.hpp	/^PointVector reshapePath(const PointVector& path, double padding)$/;"	f
rotatePoints	cgutil.hpp	/^PointVector rotatePoints(const PointVector& points, double angle_rad)$/;"	f
